## 汉明距离总和
---
### 方法一
前一天的题目是汉明距离，今天的是汉明距离总和.首先想出来的法子：把昨天的用上，然后一个个枚举两个的汉明距离加起来不就行了.所以有第一个办法，暴力枚举.

暴力枚举用到**回溯算法**
由题意可知两个数的汉明距离.那就是**深度为2的树**,所以递归出口是当路径大小达到2的时候计算上汉明距离到结果集.

C++代码
```C++
void backTrakcing(int startIndex, int depth, vector<int> &nums, vector<int> &path, int &sum) {
    if (path.size() == depth) {
        sum += __builtin_popcount(path[0] ^ path[1]);
        return;
    }

    for (int i = startIndex; i < nums.size(); i++) {
        path.push_back(nums[i]);
        backTrakcing(i + 1, depth, nums, path, sum);
        path.pop_back();
    }
}

int totalHammingDistance_overtime(vector<int>& nums) {
    int sum = 0;
    vector<int> path;
    backTrakcing(0, 2, nums, path, sum);
    return sum;
}
```

测试没问题，与预期结果一样，直接提交.
提交后发现怎么超时了😱，返回去看看题目提示:**数组的长度不超过 $10^4$**. 这么大的数，回溯必然超时.

### 方法二
不能用暴力dfs，那么就考虑考虑从每一位中进行突破.
先想想汉明距离的定义:
- 两个整数之间的汉明距离指的是这两个数字对应二进制位不同的位置的数目.

不同位置的数目，**如果我们只针对一位，算出nums里面所有数关于这个位的信息，问题就会简化了**.
一个位上只有0和1， 给予变量名存储 one, zero. 容易得到**这个位上汉明距离之和**
$$ sum = one * zero $$
现在我们只需要获得每一个数的每一个位的信息，然后加起来就得到总的汉明距离之和了.
具体遍历方式:
- 位的循环在外层 0 ～ 30 位即可
- nums元素循环在内层

C++代码
```C++
//按位判断，优化版
int totalHammingDistance(vector<int>& nums) {
    int size = nums.size();
    int total = 0;
    for (int i = 0; i < 30; i++) {
        int one = 0;
        for (int j = 0; j < nums.size(); j++) {
            one += (nums[j] >> i) & 1;
        }
        total += one * (size - one);
    }
    return total;
}
```
时间复杂度
- **O(N * K) 其中K是30**

空间复杂度
- **O(1)**
# Union-Find算法
- 主要实现API   
```java
class UF {
    /* 将 p 和 q 连接 */
    public void union(int p, int q);
    /* 判断 p 和 q 是否连通 */
    public boolean connected(int p, int q);
    /* 返回图中有多少个连通分量 */
    public int count();
}
```

- **连通**三性质
  1. **自反性**：节点 p 和 p 是连通的.
  2. **对称性**：如果节点 p 和 q 连通，那么 q 和 p 也连通.
  3. **传递性**：如果节点 p 和 q 连通，q 和 r 连通，那么 p 和 r 也连通.

- 思路
  -  用 **森林** 来表示结点之间的连通性.用一个指针指向父结点，而根结点则指向自己.
  -  代码表示:

```java
class UF {
    // 记录连通分量
    private int count;
    // 节点 x 的节点是 parent[x]
    private int[] parent;

    /* 构造函数，n 为图的节点总数 */
    public UF(int n) {
        // 一开始互不连通
        this.count = n;
        // 父节点指针初始指向自己
        parent = new int[n];
        for (int i = 0; i < n; i++)
            parent[i] = i;
    }

    public void union(int p, int q) {
        int rootP = find(p);
        int rootQ = find(q);
        if (rootP == rootQ)
            return;
        // 将两棵树合并为一棵
        parent[rootP] = rootQ;
        // parent[rootQ] = rootP 也一样
        count--; // 两个分量合二为一
    }

    /* 返回某个节点 x 的根节点 */
    private int find(int x) {
        // 根节点的 parent[x] == x
        while (parent[x] != x) {
            parent[x] = parent[parent[x]]; //路径压缩
            x = parent[x];
        }
        return x;
    }

    /* 返回当前的连通分量个数 */
    public int count() { 
        return count;
    }

    boolean isConnect(int p, int q) {
        int rootP = find(p);
        int rootQ = find(q);
        return rootP == rootQ;
    }
}
```

- **如果某两个节点被连通，则让其中的（任意）一个节点的根节点接到另一个节点的根节点上**
![连接图](并查集连接.jpeg)


- 分析 **时间复杂度**
通过代码可以发现，`union`和`isConnect`都是通过`find`进行计算的，分析`find`即可.
通过观察，最坏情况时间复杂度为`O(n)`
![森林分析](find森林分析.jpeg)

- 原因分析
合并两颗树有好的情况和坏的情况，如图所示:
![](合并情况.jpeg)

- 平衡性优化:   
```java
public void union(int p, int q) {
    int rootP = find(p);
    int rootQ = find(q);
    if (rootP == rootQ)
        return;
    // 将两棵树合并为一棵
    parent[rootP] = rootQ;
    // parent[rootQ] = rootP 也可以
    count--; 
}
```

- 加入重量，平衡化树
```java
class UF {
    private int count;
    private int[] parent;
    // 新增一个数组记录树的“重量”
    private int[] size;

    public UF(int n) {
        this.count = n;
        parent = new int[n];
        // 最初每棵树只有一个节点
        // 重量应该初始化 1
        size = new int[n];
        for (int i = 0; i < n; i++) {
            parent[i] = i;
            size[i] = 1;
        }
    }

    public void union(int p, int q) {
        int rootP = find(p);
        int rootQ = find(q);
        if (rootP == rootQ) 
            return;
        
        // 小树接到大树下面，较平衡
        if (size[rootP] > size[rootQ]) {
            parent[rootQ] = rootP;
            size[rootP] += size[rootQ];
        } else {
            parent[rootP] = rootQ;
            size[rootQ] += size[rootP];
        }
        count--;
    }
}
```

---

### 完整代码
```java
class UF {
    // 连通分量个数
    private int count;
    // 存储一棵树
    private int[] parent;
    // 记录树的“重量”
    private int[] size;

    public UF(int n) {
        this.count = n;
        parent = new int[n];
        size = new int[n];
        for (int i = 0; i < n; i++) {
            parent[i] = i;
            size[i] = 1;
        }
    }
    
    public void union(int p, int q) {
        int rootP = find(p);
        int rootQ = find(q);
        if (rootP == rootQ)
            return;
        
        // 小树接到大树下面，较平衡
        if (size[rootP] > size[rootQ]) {
            parent[rootQ] = rootP;
            size[rootP] += size[rootQ];
        } else {
            parent[rootP] = rootQ;
            size[rootQ] += size[rootP];
        }
        count--;
    }

    public boolean connected(int p, int q) {
        int rootP = find(p);
        int rootQ = find(q);
        return rootP == rootQ;
    }

    private int find(int x) {
        while (parent[x] != x) {
            // 进行路径压缩
            parent[x] = parent[parent[x]];
            x = parent[x];
        }
        return x;
    }

    public int count() {
        return count;
    }
}
```

- **C++实现**
```C++
class UF {
public:
    UF(int n) : count_(n) {
        parent_ = vector<int>(n);
        size_ = vector<int>(n);
        for (int i = 0; i < n; ++i) {
            parent_[i] = i;
            size_[i] = 1;
        }
    }

    void union(int p, int q) {
        int rootP = find(p);
        int rootQ = find(q);
        if (rootP == rootQ)
            return;
        
        //小树接到大树
        if (size_[rootP] > size_[rootQ]) {
            parent_[rootQ] == rootP;
            size_[rootP] += size_[rootQ];
        }
        else {
            parent_[rootP] = rootQ;
            size_[rootQ] += size_[rootP];
        }

        count_--; 
    }

    int find(int x) {
        while (parent_[x] != x) {
            parent_[x] = parent_[parent_[x]];   //实现路径压缩
            x = parent_[x];
        }
        return x;
    }

    bool isConnect(int p, int q) {
        return find(p) == find(q);
    }

    int getCount() {
        return count_;
    }


private:
    int count_;         //连通分量
    vector<int> parent_; //一颗树
    vector<int> size_;   //重量
};
```

### Leetcode题目
- **Leetcode 232**
```C++
给定编号从 0 到 n-1 的 n 个节点和一个无向边列表（每条边都是一对节点），请编写一个函数来计算无向图中连通分量的数目。

示例 1:

输入: n = 5 和 edges = [[0, 1], [1, 2], [3, 4]]

     0          3
     |          |
     1 --- 2    4

输出: 2

示例 2:

输入: n = 5 和 edges = [[0, 1], [1, 2], [2, 3], [3, 4]]

     0           4
     |           |
     1 --- 2 --- 3

输出:  1

注意:
你可以假设在 edges 中不会出现重复的边。而且由于所以的边都是无向边，[0, 1] 与 [1, 0]  相同，所以它们不会同时在 edges 中出现。
```

```C++
class Union_Find {
public:
    Union_Find(int n) : count_(n) {
        parent = std::vector<int>(n);
        rank = std::vector<int>(n, 1);
        for (int i = 0; i < n; ++i)
            parent[i] = i;
    }

    int getCount() {return count_;}

    void unionNode(int p, int q) {
        int rootP = find(p);
        int rootQ = find(q);
        if (rootP == rootQ)
            return;

        if (rank[rootQ] > rank[rootP]) {
            parent[rootP] = rootQ;
            rank[rootQ] += rank[rootP];
        }
        else {
            parent[rootQ] = rootP;
            rank[rootP] += rank[rootQ];
        }
        count_--;
    }

    int find(int x) {
        while (x != parent[x]) {
            parent[x] = parent[parent[x]];
            x = parent[x];
        }
        return x;
    }

    bool isConnect(int p, int q) {return find(p) == find(q);}

private:
    int count_;
    std::vector<int> parent;
    std::vector<int> rank;
};
```

---

- **130 被围绕的区域**
```C++
class Solution {
public:
    /* 边界的棋子是无敌的
     * 并查集思路: 如果有和边界相连的o棋子就是无敌的,其他通通被吃
     */
    void solve(vector<vector<char>>& board) {
        int m = board.size();
        int n = board[0].size();
        vector<vector<int>> director{{0, 1}, {0, -1}, {-1, 0}, {1, 0}}; //方向数组
        Union_Find UF(n * m + 1);               //并查集类
        int dummy = m * n;                      //虚拟位

        //左右边界
        for (int i = 0; i < m; ++i) {
            if (board[i][0] == 'O')
                UF.unionNode(i * n, dummy);
            if (board[i][n - 1] == 'O')
                UF.unionNode(i * n + n - 1, dummy);
        }
        //上下边界
        for (int i = 0; i < n; ++i) {
            if (board[0][i] == 'O') 
                UF.unionNode(i, dummy);
            if (board[m - 1][i] == 'O')
                UF.unionNode((m - 1) * n + i, dummy);
        }

        //搜索连通
        for (int i = 1; i < m - 1; ++i) {
            for (int j = 1; j < n - 1; ++j) {
                if (board[i][j] == 'O') {
                    for (int k = 0; k < 4; ++k) {           //四个方向查找
                        int x = i + director[k][0];
                        int y = j + director[k][1];
                        if (board[x][y] == 'O')             //找到连通的O进行相连
                            UF.unionNode(x * n + y, i * n + j);
                    }
                }
            }
        }

        //如果和无敌点不连通的就改成X
        for (int i = 1; i < m; ++i) {
            for (int j = 1; j < n; ++j) {
                if (!UF.isConnect(dummy, i * n + j))
                    board[i][j] = 'X';
            }
        }
    }

private:
    class Union_Find {
    public:
        Union_Find(int n) : count_(n) {
            parent = std::vector<int>(n);
            rank = std::vector<int>(n, 1);
            for (int i = 0; i < n; ++i)
                parent[i] = i;
        }

        int getCount() {return count_;}

        void unionNode(int p, int q) {
            int rootP = find(p);
            int rootQ = find(q);
            if (rootP == rootQ)
                return;

            if (rank[rootQ] > rank[rootP]) {
                parent[rootP] = rootQ;
                rank[rootQ] += rank[rootP];
            }
            else {
                parent[rootQ] = rootP;
                rank[rootP] += rank[rootQ];
            }
            count_--;
        }

        int find(int x) {
            while (x != parent[x]) {
                parent[x] = parent[parent[x]];
                x = parent[x];
            }
            return x;
        }

        bool isConnect(int p, int q) {return find(p) == find(q);}

    private:
        int count_;
        std::vector<int> parent;
        std::vector<int> rank;
    };
};
```

- **990 等式方程的可满足性**
```C++
class Solution {
public:
    /*
     * 思路:并查集解决
     * 本质上就是验证结点是否同根
     */
    bool equationsPossible(vector<string>& equations) {
        unordered_map<char, int> my_map;
        init(my_map, equations);
        Union_Find UF(my_map.size());
        
        //进行结点连通
        for (string &equation : equations) {
            char var1 = equation[0];
            char var2 = equation[3];
            char oper = equation[1];
            if (oper == '=') 
                UF.unionNode(my_map[var1], my_map[var2]);
        }
        
        //检查各个等式
        for (string &equation : equations) {
            char var1 = equation[0];
            char var2 = equation[3];
            char oper = equation[1];
            bool sameRoot = UF.isConnect(my_map[var1], my_map[var2]);
            if (oper == '!' && sameRoot == true) 
                return false;
            else if (oper == '=' && sameRoot == false)
                return false;
        } 
        return true;
    }

protected:
    // 构建哈希表
    void init(unordered_map<char, int> &my_map, vector<string> &equations) {
        int index = 0;
        for (string &equation : equations) {
            if (!my_map.count(equation[0])) 
                my_map[equation[0]] = index++;
            if (!my_map.count(equation[3]))
                my_map[equation[3]] = index++;
        }
    }

private:
    class Union_Find {
    public:
        Union_Find(int n) : count_(n) {
            parent = std::vector<int>(n);
            rank = std::vector<int>(n, 1);
            for (int i = 0; i < n; ++i)
                parent[i] = i;
        }

        int getCount() {return count_;}

        void unionNode(int p, int q) {
            int rootP = find(p);
            int rootQ = find(q);
            if (rootP == rootQ)
                return;

            if (rank[rootQ] > rank[rootP]) {
                parent[rootP] = rootQ;
                rank[rootQ] += rank[rootP];
            }
            else {
                parent[rootQ] = rootP;
                rank[rootP] += rank[rootQ];
            }
            count_--;
        }

        int find(int x) {
            while (x != parent[x]) {
                parent[x] = parent[parent[x]];
                x = parent[x];
            }
            return x;
        }

        bool isConnect(int p, int q) {return find(p) == find(q);}

    private:
        int count_;
        std::vector<int> parent;
        std::vector<int> rank;
    };
};
```
# 广度优先搜索
- 问题本质:在一幅图中从起点到终点的最近距离.
- 抽象地来说: DFS是线 BFS是面

### 双向BFS
- 需要知道终点在哪才可以进行

经典小习题
- 二叉树的最小深度
- 转盘锁
```C++
class Solution {
public:
    int openLock(vector<string>& deadends, string target) {
        unordered_set<string> visited(getVisited(deadends)); //记录非法数字
        if (visited.count("0000")) //一开始就跪了
            return -1;
        if (target == "0000") //一开始就成了
            return 0;
        queue<string> q;
        int step = 0; //记录次数
        q.push("0000");
        while (!q.empty()) {
            step += 1;   //次数加1
            int size = q.size();
            for (int i = 0; i < size; ++i) { //单层操作
                string cur = q.front();
                q.pop();
                for (int j = 0; j < 4; ++j) { //对四个位进行扭转
                    string next = trunUp(cur, j);
                    string pre = trunDown(cur, j);
                    if (next == target || pre == target) //如果符合了，返回次数
                        return step;
                    if (visited.count(next) == 0) { //查看记录里面是否含有这个防止重复或死亡
                        visited.insert(next);
                        q.push(next);
                    }
                    if (visited.count(pre) == 0) { //查看记录里面是否含有这个防止重复或死亡
                        visited.insert(pre);
                        q.push(pre);
                    }
                }
            }
        }
        return -1; //找不到，返回-1
    }

private:
    unordered_set<string> getVisited(vector<string> &deadends) {
        unordered_set<string> s;
        s.insert(deadends.begin(), deadends.end());
        return s;
    }

    string trunUp(string &s, int index) {
        string res = s;
        if (res[index] == '9')
            res[index] = '0';
        else
            res[index] = res[index] + 1;
        return res;
    }

    string trunDown(string &s, int index) {
        string res = s;
        if (res[index] == '0') 
            res[index] = '9';
        else 
            res[index] = res[index] - 1;
        return res;
    }
};
```


---

- **815 公交路线**
```C++
class Solution {
public:
    int numBusesToDestination(vector<vector<int>>& routes, int source, int target) {
        if (source == target)  //起点和终点相同
            return 0;
        unordered_map<int, vector<int>> mp; //优化哈希表，记录该站对应的公交车
        vector<bool> visited(routes.size(), false); //记录站点
        queue<int> q; //广度搜索队列
        init(routes, mp); //初始化哈希表
        q.push(source); //加入起点
        int steps = 0;  //记录乘坐车辆次数，其实就是BFS的层数
        while (!q.empty()) {
            steps++; //层次+1
            int size = q.size();
            for (int i = 0; i < size; i++) { //遍历一层
                int site = q.front();
                q.pop();
                for (auto &r : mp[site]) {  //遍历该车站对应的车趟
                    if (!visited[r]) {      //检查是否来过
                        visited[r] = true;
                        for (int k = 0; k < routes[r].size(); k++) { //遍历该车次经过的站
                            if (routes[r][k] == target) //到达终点
                                return steps;
                            q.push(routes[r][k]);  //加入下一个站
                        }
                    }
                }
            }
        }
        return -1; //找不到返回-1
    }

private:
    //初始化函数
    void init(vector<vector<int>> &routes, unordered_map<int, vector<int>> &mp) {
        for (int i = 0; i < routes.size(); i++) {
            for (int j = 0; j < routes[i].size(); j++) {
                mp[routes[i][j]].push_back(i);      
            }
        }
    }
};
```
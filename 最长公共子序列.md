# 最长公共子序列
- **思路**
一般这种求解两个数组或者字符串求最大或者最小的题目都可以考虑动态规划，并且通常都定义 dp[i][j] 为 以 A[i], B[j] 结尾的 xxx。这道题就是：以 A[i], B[j] 结尾的两个数组中公共的、长度最长的子数组的长度.  
 ---
- **通常算法**
  1. 双层循环找出所有的 i, j 组合，时间复杂度 $O(m * n)$，其中 m 和 n 分别为 A 和 B 的 长度。
    如果 A[i] == B[j]，dp[i][j] = dp[i - 1][j - 1] + 1
    否则，dp[i][j] = 0
  1. 循环过程记录最大值即可。
---
- **常见核心代码(连续)**
```C++
if (nums1[i - 1] == nums2[j - 1])       //核心操作，状态转移
    dp[i][j] = dp[i - 1][j - 1] + 1;
```

#### 718 最长重复子数组
```C++
class Solution {
public:
    int findLength(vector<int>& nums1, vector<int>& nums2) {
        //建立dynamic programming数组多加前导位便于状态转移
        vector<vector<int>> dp(nums1.size() + 1, vector<int> (nums2.size() + 1, 0));
        int result = 0;
        for (int i = 1; i <= nums1.size(); i++) {
            for (int j = 1; j <= nums2.size(); j++) {
                if (nums1[i - 1] == nums2[j - 1])       //核心操作，状态转移
                    dp[i][j] = dp[i - 1][j - 1] + 1;
                result = max(result, dp[i][j]);
            }
        }
        return result;
    }
};
```
---
#### 1143 最长公共子序列
- 与之前连续的子序列不同，**这里的子序列可以不连续.**
- 三个方向推dp[i][j] : 
  1. dp[i - 1][j - 1] 
  2. dp[i - 1][j] 
  3. dp[i][j - 1]
----
- 主要就是两大情况: text1[i - 1] 与 text2[j - 1]相同，text1[i - 1] 与 text2[j - 1]不相同.
  1. 如果text1[i - 1] 与 text2[j - 1]相同，那么找到了一个公共元素，所以                           **dp[i][j] = dp[i - 1][j - 1] + 1**;
  2. 如果text1[i - 1] 与 text2[j - 1]不相同，那就看看text1[0, i - 2]与text2[0, j - 1]的最⻓公共子序列 和 text1[0, i - 1]与text2[0, j - 2]的最⻓公共子序列，取最大的。
  即:**dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])**;
  
  $$
  dp[i][j] = \begin{cases}
      dp[i][j] = dp[i - 1][j - 1] + 1 & text1[i - 1] = text2[j - 1]\\
      dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) & text1[i - 1] \not= text2[j - 1]
  \end{cases}
  $$
---
**核心代码:**
```C++
if (text1[i - 1] == text2[j - 1]) {
    dp[i][j] = dp[i - 1][j - 1] + 1;
}
else {
    dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]);
}
```
---
**AC代码**
```C++
class Solution {
public:
    int longestCommonSubsequence(string text1, string text2) {
        //便于状态推导，多加前导位
        vector<vector<int>> dp(text1.size() + 1, vector<int> (text2.size() + 1, 0));
        int result = 0;
        for (int i = 1; i <= text1.size(); i++) {
            for (int j = 1; j <= text2.size(); j++) {
                if (text1[i - 1] == text2[j - 1])   //匹配，长度+1
                    dp[i][j] = dp[i - 1][j - 1] + 1;
                else {                              //不匹配，记忆化最优解
                    dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]);
                }
                result = max(result, dp[i][j]);
            }
        }
        return result;
    }
};
```
---

#### 1035 不相交的线
- 抽象之力～ 如果不相交，相对位置一致，其实就是**公共子序列**.只是1143换了个皮.
**代码几乎一模一样**
```C++
class Solution {
public:
    int maxUncrossedLines(vector<int>& nums1, vector<int>& nums2) {
    int size1 = nums1.size();
    int size2 = nums2.size();
    vector<vector<int>> dp(size1 + 1, vector<int>(size2 + 1, 0));
    for (int i = 1; i < size1 + 1; i++) {
        for (int j = 1; j < size2 + 1; j++) {
            if (nums1[i - 1] == nums2[j - 1]) {
                dp[i][j] = dp[i - 1][j - 1] + 1;
            }
            else {
                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]);
            }
        }
    }
    return dp[size1][size2];
}
};
```
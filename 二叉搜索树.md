# 二叉搜索树
 - **二叉搜索树之特性**
      1. 对于 BST 的每一个节点 node，左子树节点的值都比 node 的值要小，右子树节点的值都比 node 的值大.
      2. 对于 BST 的每一个节点 node，它的左侧子树和右侧子树都是 BST.
      3. 二叉搜索树的中序遍历是有序的.

---

- **230. 二叉搜索树中第K小的元素**
```C++
//中序计数即可
class Solution {
public:
    int kthSmallest(TreeNode* root, int k) {
        int rank = 0;
        travel(root, rank, k);
        return result;
    }

    void travel(TreeNode *root, int &rank, int k) {
        if (root == nullptr)
            return;
        travel(root->left, rank, k);
        rank++;
        if (rank == k) {
            result = root->val;
            return;
        }
        travel(root->right, rank, k);
    }

private:
    int result;
};
```

---

- **538. 把二叉搜索树转换为累加树**
- **1038 累加二叉搜索树**
```C++
// 利用中序升序的规律，反中序进行累加即可
class Solution {
public:
    TreeNode* convertBST(TreeNode* root) {
        preVal = 0;
        travel(root);
        return root;
    }

    void travel(TreeNode *root) {
        if (root == nullptr)
            return;
        travel(root->right);
        root->val += preVal;
        preVal = root->val;
        travel(root->left);
    }

private:
    int preVal;
};
```

---

- **细节判断BST**
```java
boolean isValidBST(TreeNode root) {
    return isValidBST(root, null, null);
}

/* 限定以 root 为根的子树节点必须满足 max.val > root.val > min.val */
boolean isValidBST(TreeNode root, TreeNode min, TreeNode max) {
    // base case
    if (root == null) return true;
    // 若 root.val 不符合 max 和 min 的限制，说明不是合法 BST
    if (min != null && root.val <= min.val) return false;
    if (max != null && root.val >= max.val) return false;
    // 限定左子树的最大值是 root.val，右子树的最小值是 root.val
    return isValidBST(root.left, min, root) 
        && isValidBST(root.right, root, max);
}
```

- **删除BST结点**
```C++
class Solution {
public:
    TreeNode* deleteNode(TreeNode* root, int key) {
        if (root == nullptr) return root; // 第一种情况：没找到删除的节点，遍历到空节点直接返回了
        if (root->val == key) {
            // 第二种情况：左右孩子都为空（叶子节点），直接删除节点， 返回NULL为根节点
            if (root->left == nullptr && root->right == nullptr) {
                ///! 内存释放
                delete root;
                return nullptr;
            }
            // 第三种情况：其左孩子为空，右孩子不为空，删除节点，右孩子补位 ，返回右孩子为根节点
            else if (root->left == nullptr) {
                auto retNode = root->right;
                ///! 内存释放
                delete root;
                return retNode;
            }
            // 第四种情况：其右孩子为空，左孩子不为空，删除节点，左孩子补位，返回左孩子为根节点
            else if (root->right == nullptr) {
                auto retNode = root->left;
                ///! 内存释放
                delete root;
                return retNode;
            }
            // 第五种情况：左右孩子节点都不为空，则将删除节点的左子树放到删除节点的右子树的最左面节点的左孩子的位置
            // 并返回删除节点右孩子为新的根节点。
            else {
                TreeNode* cur = root->right; // 找右子树最左面的节点
                while(cur->left != nullptr) {
                    cur = cur->left;
                }
                cur->left = root->left; // 把要删除的节点（root）左子树放在cur的左孩子的位置
                TreeNode* tmp = root;   // 把root节点保存一下，下面来删除
                root = root->right;     // 返回旧root的右孩子作为新root
                delete tmp;             // 释放节点内存（这里不写也可以，但C++最好手动释放一下吧）
                return root;
            }
        }
        if (root->val > key) root->left = deleteNode(root->left, key);
        if (root->val < key) root->right = deleteNode(root->right, key);
        return root;
    }
};
```

---

### 不同的BST
- **96不同的搜索树**
考虑有几种根结点的情况,然后子树也是这样的思路，形成一种递归之思想.一种为根结点数量总数为左右子树组合的个数.
```C++
// 递归之动态规划，利用备忘录减少计算量.
class Solution {
public:
    int numTrees(int n) {
        demo = vector<vector<int>> (n + 1, vector<int>(n + 1, 0));
        return count(1, n);
    }

    int count(int left, int right) {
        if (left > right) //基本情况
            return 1;
        if (demo[left][right] != 0)
            return demo[left][right];
        int result = 0;
        for (int i = left; i <= right; ++i) {
            int l = count(left, i - 1);
            int r = count(i + 1, right);
            result += l * r;  //左右子树之组合
        }
        demo[left][right] = result;
        return result;
    }

private:
    vector<vector<int>> demo;
};
```

- **构造不同的搜索树**
  1. 穷举root所有可能
  2. 递归构造子树的所有可能
  3. 穷举左右子树组合 
```C++
class Solution {
public:
    vector<TreeNode*> generateTrees(int n) {
        return help(1, n);
    }

    vector<TreeNode*> help(int start, int end) {
        vector<TreeNode*> result;
        //递归出口
        if (start > end) {
            result.push_back(nullptr);
            return result;
        }
        for (int i = start; i <= end; ++i) {
            vector<TreeNode*> leftTree = help(start, i - 1); //获得所有左子树情况
            vector<TreeNode*> rightTree = help(i + 1, end);  //获得所有右子树情况
            //穷举左右子树组合操作
            for (auto &left : leftTree) {
                for (auto &right : rightTree) {
                    TreeNode *newNode = new TreeNode(i);
                    newNode->left = left;
                    newNode->right = right;
                    result.push_back(newNode);
                }
            }
        }
        return result;
    }
};
```

---


- **如果当前节点要做的事情需要通过左右子树的计算结果推导出来，就要用到后序遍历**
- **1373二叉搜索树的最大键值和**
通过数组记录子树信息
```C++
class Solution {
public:
    int maxsum = 0;
    int maxSumBST(TreeNode* root) {
        dfs(root);
        return maxsum;
    }
    vector<int> dfs(TreeNode* root) {
        if (!root) return {true, INT_MAX, INT_MIN, 0};
        auto lArr = dfs(root->left);
        auto rArr = dfs(root->right);
        int sum = 0, curmax, curmin;
        if (!lArr[0] || !rArr[0] || root->val >= rArr[1] || root->val <= lArr[2]) {
            return {false, 0, 0, 0};
        }
        curmin = root->left ? lArr[1] : root->val;
        curmax = root->right ? rArr[2] : root->val;
        sum += (root->val + lArr[3] + rArr[3]);
        maxsum = max(maxsum, sum);
        return {true, curmin, curmax, sum};
    }
};
```
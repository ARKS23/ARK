# 滑动窗口
- 滑动窗口通常用来解决一些**连续**的问题.
- 主要三种类型:
  1. 窗口大小固定
  2. 窗口大小不固定，求解最大满足条件的窗口.
  3. 窗口大小不固定，求解最小满足条件的窗口. 

- **Python版本框架:**
```python
初始化慢指针 = 0
初始化 ans

for 快指针 in 可迭代集合
   更新窗口内信息
   while 窗口内不符合题意
      扩展或者收缩窗口
      慢指针移动
   更新答案
返回 ans
```

- **C++版本**
```C++
int left = 0, right = 0;
while (right < s.size()) {
    window.add(s[right]);
    right++;

    while (window need shrink) {
        window.remove(s[left]);
        left++;
    }
}
```

- **C++版本详细框架**
```C++
/* 滑动窗口算法框架 */
void slidingWindow(string s, string t) {
    unordered_map<char, int> need, window;
    for (char c : t) need[c]++;
    
    int left = 0, right = 0;
    int valid = 0; 
    while (right < s.size()) {
        // c 是将移入窗口的字符
        char c = s[right];
        // 右移窗口
        right++;
        // 进行窗口内数据的一系列更新
        ...

        /*** debug 输出的位置 ***/
        printf("window: [%d, %d)\n", left, right);
        /********************/
        
        // 判断左侧窗口是否要收缩
        while (window needs shrink) {
            // d 是将移出窗口的字符
            char d = s[left];
            // 左移窗口
            left++;
            // 进行窗口内数据的一系列更新
            ...
        }
    }
}
```

---
### **例题**
- **209 长度最小的子数组**
- 分析：这题所求的子数组是**连续**的，因此容易联想到滑动窗口来解决.  
容易看出，这题的滑动窗口类型属于上述第三种，我们需要更新窗口的大小来满足条件.
- **C++代码:**
```C++
class Solution {
public:
    int minSubArrayLen(int target, vector<int>& nums) {
        int slow = 0;           //设定慢指针
        int result = INT_MAX;   //也可以设定为nums.size() + 1
        int cur = 0;            //用来记录目前窗口内的数字总和
        for (int fast = 0; fast < nums.size(); fast++) { //快指针循环
            cur += nums[fast];                          //加上当前快指针的值
            while (cur >= target) {                     //已经满足条件了就记录当前数据并尝试缩小范围
                result = min(result, fast - slow + 1);  //取最优解
                cur -= nums[slow];                      //窗口缩小，总和应该减去慢指针的值
                slow++;                                 //慢指针向前移动，窗口缩小
            }
        }
        return result == INT_MAX ? 0 : result;          //判断是否存在符合条件的结果,都不符合就返0
    }   
};
```
- **Python代码**
```Python
class Solution:
    def minSubArrayLen(self, s: int, nums: List[int]) -> int:
        l = total = 0
        ans = len(nums) + 1
        for r in range(len(nums)):
            total += nums[r]
            while total >= s:
                ans = min(ans, r - l + 1)
                total -= nums[l]
                l += 1
        return  0 if ans == len(nums) + 1 else ans
```
---
- **3 无重复字符的最长子串**
- 分析:由题目可知所求的子串是**连续**的,可以使用滑动窗口.  
窗口的大小是**可变动**的，是上述第二种情况，求满足**最大时**的情况.
- 具体思路:
  1. 设置一个慢指针从下标0开始,快指针也是从下标0开始,再设置一个**map记录字符下标**.
  2. 快指针向前移动,每次**移动就从map里检查有没重复字符串**.
     - 若没有重复字符,**比较当前长度与之前记录的长度大小，取最优解**.
     - 若存在重复字符,找到当前字符对应的下标,**slow指针一直前移至这个下标**,同时删除这个下标之前的map记录,**最后更新fast字符下标**.
  3. 重复上述过程. 

**C++代码:**
```C++
class Solution {
public:
    int lengthOfLongestSubstring(string s) {
        int size = s.size();
        if (size < 2)  return size;      //特值判断
        int result = 0;                  //设置为1也行
        int slow = 0;                    //慢指针
        unordered_map<char, int> record; //记录的map
        for (int fast = 0; fast < s.size(); fast++) {
            char cur = s[fast];        
            if (record.count(cur) == 0) { //若当前的字符不重复，扩大窗口
                result = max(result, fast - slow + 1); //取长度最优解
                record[cur] = fast;       //加入map记录中
            }
            else {                       //存在重复情况
                int index = record[cur]; //取得重复下标
                while (slow <= index) {  
                    record.erase(s[slow]); //缩小窗口，删除记录
                    slow++;                //慢指针前移，缩小窗口
                }
                record[cur] = fast;       //更新字符下标
            }
        }
        return result;
    }
};
```

**Python代码:**
```Python
from collections import defaultdict
class Solution:
    def lengthOfLongestSubstring(self, s: str) -> int:
        l = 0
        ans = 0
        counter = defaultdict(lambda: 0)

        for r in range(len(s)):
            while counter.get(s[r], 0) != 0:
                counter[s[l]] = counter.get(s[l], 0) - 1
                l += 1
            counter[s[r]] += 1
            ans = max(ans, r - l + 1)

        return ans
```

---

- **904 水果成篮**
  分析:题目要求的篮子数是2，最多只能装两种类型的水果.
  用map记录水果数量，如果map的大小大于2则代表篮子不够装了，就要缩小范围直到只剩两种水果！

**C++代码**
```C++
class Solution {
public:
    int totalFruit(vector<int>& tree) {
        int result = 0;         //结果收集
        int left = 0;           //窗口左端
        unordered_map<int ,int> window; //记录水果种类和数量
        for (int right = 0; right < tree.size(); right++) {
            window[tree[right]]++;          //水果数量+1
            while (window.size() > 2) {     //当水果种类大于2时，要缩小窗口
                window[tree[left]]--;       //水果数量-1
                if (window[tree[left]] == 0)//当水果数量为0，把该种类水果去除
                    window.erase(tree[left]);
                left++;                     //窗口缩小
            }
            result = max(right - left + 1, result); //取最优解
        }
        return result;
    }
};
```

---

- **76 最小覆盖子串**
  分析：滑动窗口，窗口大小可变.
  1. **如果不满足条件，扩大窗口，右端移动.** 
  2. **如果满足条件,缩小窗口，左端移动.**
  3. 用map记录目标字符串字符个数.
     1. 当对应value小于0，说明还不够，不满足条件.
     2. 当对应value大于等于0，

**C++代码**
```C++
class Solution {
public:
    string minWindow(string s, string t) {
        int slow = 0;
        int left = -1, right = -1;  //记录左右区间
        int minLen = s.size() + 1;
        unordered_map<char, int> mp;
        init(mp, t); //初始化哈希表
        for (int fast = 0; fast < s.size(); fast++) {
            char cur = s[fast];
            if (mp.count(cur))    //目标字符匹配+1
                mp[cur]++;
            while (check(mp)) {   //满足条件，缩小窗口
                if (minLen > fast - slow + 1) { //取最优解
                    minLen = fast - slow + 1;  
                    left = slow;
                    right = fast;
                }
                char scur = s[slow];
                if (mp.count(scur))
                    mp[scur]--; //如果是目标字符，就减1
                slow++;      //窗口缩小
            }
        }
        if (left == -1)     //找不到的情况
            return "";
        return string(s.begin() + left, s.begin() + (right + 1));
    }

private:
    //初始化哈希表
    void init(unordered_map<char, int> &mp, string &t) {
        for (char c : t) {
            mp[c] -= 1;
        }
    }

    //检查是否满足条件
    bool check(unordered_map<char, int> &mp) {
        for (auto i : mp) {
            if (i.second < 0)
                return false;
        }
        return true;
    }
};
```
**优化解法**
```C++
class Solution {
public:
    string minWindow(string s, string t) {
        unordered_map<char, int> catagory, window; //标准窗口和实际窗口
        for (char c : t) catagory[c]++;
        int left = 0, right = 0; //窗口左右端
        int start = 0, len = INT_MAX; //结果集
        int valid = 0;      //有效位
        while (right < s.size()) {
            if (catagory.count(s[right])) { 
                window[s[right]]++;
                if (window[s[right]] == catagory[s[right]]) { //满足一位的需要，有效位+1
                    valid += 1;
                }
            }
            while (valid == catagory.size()) { //满足所有有效位,缩小窗口,收集结果
                if (right - left < len) {
                    len = right - left;
                    start = left;
                }

                char leftCur = s[left];
                left++;
                if (catagory.count(leftCur)) {
                    window[leftCur]--;
                    if (window[leftCur] < catagory[leftCur]) { //当不足以满足一个位,有效位-1
                        valid--;
                    }
                }
            }
            right++;
        }
        return len == INT_MAX ? "" : s.substr(start, len + 1); //查看是否有满足条件的
    }
};
```

---

- **992 不同K个数字的数组个数**
分析: 利用动态规划的思想 符合条件的数组累加 **result += right - left + 1**
     再根据 *最多K种 - 最多K - 1种 = K种*
     举例:先来个通俗的：张三、李四、老王， 3 个人一起吃包子，他们最多能吃 10 个包子；如果有一天老王有事没来，现在只有张三、李四两个人吃包子，他们俩最多能吃 3 个包子。求老王的饭量是能吃几个包子？
     ![](../leetcode题解/韦恩图.png)

```C++
int getMax(vector<int> &nums, int k) {
    int count = 0;
    int left = 0;
    unordered_map<int, int> mp;
    for (int right = 0; right < nums.size(); right++) {
        mp[nums[right]]++;
        while (mp.size() > k) { //超过范围，缩小窗口
            mp[nums[left]]--;
            if (mp[nums[left]] == 0) mp.erase(nums[left]);
            left++;
        }
        count += right - left + 1; //求的是当前符合条件的子数组个数，类似于动态规划推导
    }
    return count;
}

//AC代码
int subarraysWithKDistinct(vector<int>& nums, int k) {
    return getMax(nums, k) - getMax(nums, k - 1); //韦恩图得解
}
```

---

- **1004 最大连续1的数**
分析：又是**连续问题**，直接滑动窗口搞起来.当**0的数目超过给定水平就缩小窗口**.

```C++
class Solution {
public:
    int longestOnes(vector<int>& nums, int k) {
        int result = 0;
        int slow = 0;
        int cur = 0;
        for (int fast = 0; fast < nums.size(); fast++) {
            if (nums[fast] == 0) //检测为0，目前零数+1
                cur += 1;
            while (cur > k) { //当不符合条件了就缩小窗口
                if (nums[slow] == 0)
                    cur -= 1;
                slow++;
            }
            result = max(result, fast - slow + 1); //取得最优解
        }
        return result;
    }
};
```

----

- **1234平衡字符串**
分析：这题与其他题不同，外部符合条件了才缩小窗口.

```C++
class Solution {
public:
    int balancedString(string s) {
        int size = s.size();
        int target = size / 4;
        unordered_map<char, int> mp;
        for (auto c : s) mp[c]++;
        int slow = 0;
        int result = size;
        //一开始就符合条件，直接返回0
        if (mp['Q'] == target && mp['E'] == target && mp['W'] == target && mp['R'] == target)
            return 0;
        for (int fast = 0; fast < size; fast++) {
            mp[s[fast]]--;
            while (slow < size && mp['Q'] <= target && mp['W'] <= target
            && mp['E'] <= target && mp['R'] <= target) { //外部符合条件，缩小窗口
                result = min(result, fast - slow + 1); //取最优解
                mp[s[slow]]++;
                slow++;
            }
        }
        return result;
    }
};
```

---

- **1248 优美数组的个数**
分析：题目要求连续，采用滑动窗口.
    思想又是求差集的思想.

**C++代码**
```C++
class Solution {
public:
    int numberOfSubarrays(vector<int>& nums, int k) {
        return myFun(nums, k) - myFun(nums, k - 1); //求差集
    }

private:
    int myFun(vector<int> &nums, int k) {
        int slow = 0;
        int cur = 0;
        int res = 0;
        for (int fast = 0; fast < nums.size(); fast++) {
            if (nums[fast] % 2) //奇数位+1
                cur++;
            while (cur > k) {    //缩小窗口
                if (nums[slow] % 2)
                    cur--;
                slow++;
            }
            res += fast - slow + 1; //动态规划思想
        }
        return res;
    }
};
```

----

- **438 字母异位**
```C++
class Solution {
public:
    vector<int> findAnagrams(string s, string p) {
        vector<int> result;
        unordered_map<char, int> need, window;
        for (char c : p) need[c]++; //目标集
        int left = 0, right = 0;
        int valid = 0;
        while (right < s.size()) {
            char curRight = s[right];
            right++;                //记得在这里就加+1
            if (need.count(curRight)) {
                window[curRight]++;
                if (window[curRight] == need[curRight])  //一个位置符合条件，有效位置+1
                    valid++;
            }
            while (right - left >= p.size()) { //符合条件缩小窗口
                char curLeft = s[left];
                if (valid == need.size())       //符合目标集
                    result.push_back(left);
                left++;
                if (need.count(curLeft)) {     
                    if (window[curLeft] == need[curLeft]) //失去一个符合条件位
                        valid--;
                    window[curLeft]--;
                }
            }
        }
        return result;
    }
};
```
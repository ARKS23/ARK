### 股票问题
- 动态规划求解问题
核心思路: `状态` 和 `选择`.

**状态转移代码:**
```C++
dp[i][k][0] = max(dp[i-1][k][0], dp[i-1][k][1] + prices[i])
              max(   选择 rest  ,             选择 sell      )

// 解释：今天我没有持有股票，有两种可能：
// 要么是我昨天就没有持有，然后今天选择 rest，所以我今天还是没有持有；
// 要么是我昨天持有股票，但是今天我 sell 了，所以我今天没有持有股票了。

dp[i][k][1] = max(dp[i-1][k][1], dp[i-1][k-1][0] - prices[i])
              max(   选择 rest  ,           选择 buy         )

// 解释：今天我持有着股票，有两种可能：
// 要么我昨天就持有着股票，然后今天选择 rest，所以我今天还持有着股票；
// 要么我昨天本没有持有，但今天我选择 buy，所以今天我就持有股票了。
```

---

- **121 买卖股票的最佳时机**

*直观dp数组解法*
```C++
class Solution {
public:
    //注意，只能交易一次
    int maxProfit(vector<int>& prices) {
        vector<vector<int>> dp(prices.size(), vector<int> (2, 0));
        dp[0][1] = -prices[0];
        for (int i = 1; i < prices.size(); ++i) {
            dp[i][0] = max(dp[i - 1][0], dp[i - 1][1] + prices[i]);
            dp[i][1] = max(-prices[i], dp[i - 1][1]);
        }
        return dp[prices.size() - 1][0];
    }
};
```

*压缩空间版*
```C++
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        int Empty = 0;
        int Hold = -prices[0];
        for (int i = 1; i < prices.size(); ++i) {
            Empty = max(Hold + prices[i], Empty);
            Hold = max(Hold, -prices[i]);
        }
        return Empty;
    }
};
```

---

- **122 买卖股票最佳时机II**
相当于121的变形，可以买无穷次.

*直观dp数组解法*
```C++
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        vector<vector<int>> dp(prices.size(), vector<int> (2, 0));
        dp[0][1] = -prices[0];
        for (int i = 1; i < prices.size(); ++i) {
            dp[i][0] = max(dp[i - 1][0], dp[i - 1][1] + prices[i]);
            dp[i][1] = max(dp[i - 1][1], dp[i - 1][0] - prices[i]);
        }
        return dp[prices.size() - 1][0];
    }
};
```

*空间压缩版*
```C++
class Solution {
public:
    //滚动数组减少内存空间的消耗
    int maxProfit(vector<int>& prices) {
        vector<vector<int>> dp(2, vector<int> (2, 0));
        dp[0][1] = -prices[0];
        for (int i = 1; i < prices.size(); ++i) {
            dp[i % 2][0] = max(dp[(i - 1) % 2][0], dp[(i - 1) % 2][1] + prices[i]);
            dp[i % 2][1] = max(dp[(i - 1) % 2][1], dp[(i - 1) % 2][0] - prices[i]);
        }
        return max(dp[0][0], dp[1][0]);
    }
};
```

---

- **309 含冷冻期股票**
```C++
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        vector<vector<int>> dp(2, vector<int> (3, 0));
        dp[0][1] = -prices[0];
        for (int i = 1; i < prices.size(); ++i) {
            dp[i % 2][0] = max(dp[(i - 1) % 2][0], dp[(i - 1) % 2][2]); //不持股票
            dp[i % 2][1] = max(dp[(i - 1) % 2][0] - prices[i], dp[(i - 1) % 2][1]); //持有股票
            dp[i % 2][2] = dp[(i - 1) % 2][1] + prices[i]; //冷冻期
        }
        int M1 = max(dp[0][0], dp[0][2]);
        int M2 = max(dp[1][0], dp[1][2]);
        return max(M1, M2);
    }
};
```

---

- **714 股票含手续费**
```C++
class Solution {
public:
    int maxProfit(vector<int>& prices, int fee) {
        vector<vector<int>> dp(2, vector<int>(2, 0));
        dp[0][1] = -prices[0] - fee;
        for (int i = 1; i < prices.size(); ++i) {
            dp[i % 2][0] = max(dp[(i - 1) % 2][0], dp[(i - 1) % 2][1] + prices[i]);
            dp[i % 2][1] = max(dp[(i - 1) % 2][1], dp[(i - 1) % 2][0] - prices[i] - fee);
        }
        return max(dp[0][0], dp[1][0]);
    }
};
```

---

- **123 两次交易股票问题**
```C++
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        int k = 2; //最大交易次数
        vector<vector<vector<int>>> dp(2, vector<vector<int>>(k + 1, vector<int>(2, 0)));
        for (int i  = 1; i <= k; ++i) {
            dp[0][i][1] = -prices[0];
        }
        for (int i = 1; i < prices.size(); ++i) {
            for (int j = k; j >= 1; --j) {
                dp[i % 2][j][0] = max(dp[(i - 1) % 2][j][0], dp[(i - 1) % 2][j][1] + prices[i]);
                dp[i % 2][j][1] = max(dp[(i - 1) % 2][j][1], dp[(i - 1) % 2][j - 1][0] - prices[i]);
            }
        }
        return max(dp[0][k][0], dp[1][k][0]);
    }
};
```

---

- **188 k次交易股票问题**
```C++
class Solution {
public:
    int maxProfit(int k, vector<int>& prices) {
        if (prices.size() <= 1)
            return 0;
        vector<vector<vector<int>>> dp(2, vector<vector<int>>(k + 1, vector<int>(2, 0)));
        for (int i  = 1; i <= k; ++i) {
            dp[0][i][1] = -prices[0];
        }
        for (int i = 1; i < prices.size(); ++i) {
            for (int j = k; j >= 1; --j) {
                dp[i % 2][j][0] = max(dp[(i - 1) % 2][j][0], dp[(i - 1) % 2][j][1] + prices[i]);
                dp[i % 2][j][1] = max(dp[(i - 1) % 2][j][1], dp[(i - 1) % 2][j - 1][0] - prices[i]);
            }
        }
        return max(dp[0][k][0], dp[1][k][0]);
    }
};
```

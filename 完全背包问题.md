# 完全背包问题
### 组合问题
- **组合问题物品遍历在外层，背包遍历在内层.**
  - 比如只会出现{5,10}，而不会出现{10,5}
- **核心代码**
```C++
for (int i = 0; i < article.size(); i++) { //物品
    for (int j = article[i]; j <= bagsize; j++) //背包
        dp[j] += dp[j - article[i]];        //组合通常的转移方程
}
```

**例题:**
- **518 零钱兑换**
题目明确说明了求组合数，我们用组合的方法进行求解.
```C++
class Solution {
public:
    int change(int amount, vector<int>& coins) {
        vector<int> dp(amount + 1, 0);
        dp[0] = 1;  //初始化便于推导
        //求组合问题
        for (int i = 0; i < coins.size(); i++) {  //物品遍历在外层
            for (int j = coins[i]; j <= amount; j++) { //背包遍历在内层
                dp[j] += dp[j - coins[i]];
            }
        }
        return dp[amount];
    }
};
```
- **279 完全平方数**
抽象成背包问题，**题目中的同一个数可以重复取，故又可以看成完全背包问题**.
```C++
class Solution {
public:
    //完全背包问题
    int numSquares(int n) {
        vector<int> dp(n + 1, INT_MAX);
        dp[0] = 0;          //便于推导
        for (int i = 1; i <= n; i++) { //外层遍历物品
            int square = i * i;
            for (int j = square; j <= n; j++) { //内层遍历背包
                dp[j] = min(dp[j], dp[j - square] + 1); //状态转移
            }
        }
        return dp[n];
    }
};
```

---

### 排列问题
- **排列问题就要背包遍历在外层，物品遍历在内层.**
  - 比如会出现{5,10}, 也会出现{10, 5}
- **核心代码**
```C++
for (int i = 0; i <= bagsize; i++) { //背包遍历在外层
    for (int j = 0; j < article.size(); j++) { //物品遍历在内层
        if (i - article[j] >= 0)    //检查防止越界
            dp[i] += dp[i - article[j]]; //状态转移
    }
}
```

**例题:**
- **377 排列总和**
```C++
class Solution {
public:
    int combinationSum4(vector<int>& nums, int target) {
        vector<int> dp(target + 1, 0);
        dp[0] = 1; //初始化，便于推导
        //排列问题，注意循环
        for (int i = 0; i <= target; i++) { //背包外层循环
            for (int j = 0; j < nums.size(); j++) { //物品内层循环
                if (i - nums[j] >= 0 && dp[i] < INT_MAX - dp[i - nums[j]]) //数值溢出处理
                    dp[i] += dp[i - nums[j]];
            }
        }
        return dp[target];
    }
};
```
- 1449 数位成本和为目标值的最大数字
```C++
class Solution {
public:
    //AC代码 关键处理要等于target
    //自定义字符串比较大小 长的字符串必然大，相等长度就比较第一个比较大的字符
    string largestNumber(vector<int>& cost, int target) {
        vector<string> dp(target + 1, "0");
        dp[0] = "";
        for (int j = 1; j <= target; j++) {
            for (int i = 0; i < cost.size(); i++) {
                if (j - cost[i] < 0 || dp[j - cost[i]] == "0")
                    continue;
                int real = i + 1;
                string temp = dp[j - cost[i]]; temp.push_back('0' + real);
                if (temp.size() > dp[j].size()) {
                    dp[j] = temp;
                    continue;
                }
                if (temp.size() == dp[j].size() && temp > dp[j])
                    dp[j] = temp;
            }
        }
        return dp[target];
    }
};
```

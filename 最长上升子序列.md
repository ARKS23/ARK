# 最长上升子序列
- **核心思想**
  动态规划，从子序列里面找比目前小的数字，然后取最优解.
  状态转移方程:
  ```C++
  if (nums[j] < nums[i])
        dp[i] = max(dp[i], dp[j] + 1);
  ```
  时间复杂度: $O(n^2)$
---
### 435 无折叠区间
##### 抽象之力，抽象成非严格递增序列.前一位结束与后一位的开始相比较.
```C++
class Solution {
public:
    int eraseOverlapIntervals(vector<vector<int>>& intervals) {
        if (intervals.size() == 1) //特值判断
            return 0;
        sort(intervals.begin(), intervals.end(), [](vector<int> &a, vector<int> &b) {
            return a[0] < b[0];
        });  //升序排序
        int longest = 0;
        vector<int> dp(intervals.size(), 1);
        for (int i = 1; i < intervals.size(); i++) {
            for (int j = 0; j < i; j++) {
                if (intervals[i][0] >= intervals[j][1]) //核心步骤，状态转移
                    dp[i] = max(dp[i], dp[j] + 1);
                longest = max(longest, dp[i]);
            }
        }
        return intervals.size() - longest;
    }
};
```
---
### 646 最长数对链
**也是抽象成递增序列，进行动态规划**
```C++
class Solution {
public:
    int findLongestChain(vector<vector<int>>& pairs) {
        sort(pairs.begin(), pairs.end(), [](vector<int> &a, vector<int> &b) {
            return a[0] < b[0];
        });
        int result = 1;
        vector<int> dp(pairs.size(), 1);
        for (int i = 1; i < pairs.size(); i++) {
            for (int j = 0; j < i; j++) {
                if (pairs[j][1] < pairs[i][0]) 
                    dp[i] = max(dp[i], dp[j] + 1);
            }
            result = max(dp[i], result);
        }
        return result;
    }
};
```

---

### 354 俄罗心信封套娃问题(Hard)
- 也能抽象成递增序列问题，不过是二维递增
```C++
class Solution {
public:
    int maxEnvelopes(vector<vector<int>>& envelopes) {
        sort(envelopes.begin(), envelopes.end(), [](vector<int> &a, vector<int> &b) {
            if (a[0] < b[0])
                return true;
            else if (a[0] == b[0]) {
                return a[1] < b[1];
            }
            else
                return false;
        });
        vector<int> dp(envelopes.size(), 1);
        int result = 1;
        for (int i = 1; i < envelopes.size(); i++) {
            for (int j = 0; j < i; j++) {
                if (envelopes[j][0] < envelopes[i][0] && envelopes[j][1] < envelopes[i][1]) 
                    dp[i] = max(dp[i], dp[j] + 1);
                result = max(result, dp[i]);
            }
        }
        return result;
    }
};
```

---
### 960 删列造序
- 抽象成维护多个递增序列. 把删除列转换成: **长度 - 最长递增序列**

```C++
class Solution {
public:
    int minDeletionSize(vector<string>& strs) {
        int big_size = strs.size();     //整个字符串数组的长度
        int small_size = strs[0].size(); //里面字符串的长度
        int result = small_size - 1; //不能全删，保留一个元素也是有序的
        vector<int> dp(small_size, 1); //dp数组，记录最长递增序列
        for (int i = 1; i < small_size; i++) { //同时判断所有序列，即判断每一列是否符合条件
            for (int j = 0; j < i; j++) {
                bool flag = true; //标记所有字符串是否递增
                for (int k = 0; k < big_size; k++) {
                    if (strs[k][j] > strs[k][i])
                        flag = false;      //如果一个不符合条件了，就标记false,老鼠屎坏好汤.
                }
                if (flag)
                    dp[i] = max(dp[i], dp[j] + 1);  //如果都符合条件，全体递增序列长度+1
                result = min(result, small_size - dp[i]); //删去最小值转化为:长度-最长递增序列
            } 
        }
        return result; 
    }
};
```
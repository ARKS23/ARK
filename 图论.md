# 图论
- **图之遍历框架**
```C++
Graph graph;
boolean[] visited;

/* 图遍历框架 */
void traverse(Graph graph, int s) {
    if (visited[s]) return;
    // 经过节点 s
    visited[s] = true;
    for (TreeNode neighbor : graph.neighbors(s))
        traverse(neighbor);
    // 离开节点 s
    visited[s] = false;   
}
```

- **797所有可能的路径**
```C++
class Solution {
public:
    vector<vector<int>> allPathsSourceTarget(vector<vector<int>>& graph) {
        travel(graph, 0, graph.size() - 1);
        return result;
    }

    void travel(vector<vector<int>> &graph, int cur, int n) {
        path.push_back(cur); //增入路径

        //到达终点
        if (cur == n) {
            result.push_back(path);
            path.pop_back();
            return;
        }
        //遍历邻结点
        for (auto &i : graph[cur]) {
            travel(graph, i, n);
        }
        path.pop_back(); //回溯
    }

private:
    vector<vector<int>> result; //结果集
    vector<int> path;           //路径
};
```

---

- **207课程表**
核心问题是判断图中有无环路
```C++
class Solution {
public:
    bool canFinish(int numCourses, vector<vector<int>>& prerequisites) {
        auto my_list(BuildList(numCourses, prerequisites)); //构建邻接链表
        visited = vector<bool>(numCourses, false);  //标记访问结点
        onPath = visited;         // 回环记录
        has_circle = false;       // 是否存在环之标记
        for (int i = 0; i < numCourses; ++i) //由于结点可能单独存在，每个结点都作为起点遍历一次
            travel(i, my_list);
        return !has_circle;
    }

    void travel(int cur, vector<list<int>> &my_list) {
        if (onPath[cur]) //回到入口，存在环
            has_circle = true;
        if (visited[cur]) //当前结点已经遍历过
            return;
        visited[cur] = true; //标记结点遍历过
        onPath[cur] = true;  //入口标记
        for (auto next : my_list[cur]) //DFS
            travel(next, my_list);
        onPath[cur] = false; //回溯
    }

    // 构建邻接链表
    vector<list<int>> BuildList(int numCourses, vector<vector<int>> &prerequisites) {
        vector<list<int>> myList(numCourses, list<int>());
        for (auto &ele : prerequisites) {
            int from = ele[1];
            int to = ele[0];
            myList[from].push_back(to);
        }
        return myList;
    }

private:
    vector<bool> visited;
    vector<bool> onPath;
    bool has_circle;
};
```

---

- **210课程表II**
如果一个图是**有向无环图**，则该图是可以进行**拓扑排序**的.
此搜索是**后序遍历**的,结果**进行反转**就是正常结果.
```C++
class Solution {
public:
    vector<int> findOrder(int numCourses, vector<vector<int>>& prerequisites) {
        visited = vector<bool>(numCourses, false);
        on_path = visited;
        has_circle = false;
        auto my_list(BuildList(numCourses, prerequisites));
        for (int i = 0; i < numCourses; ++i) //由于结点可能是独立的，要单独作为入口进行DFS
            travel(i, my_list);
        if (!has_circle) {
            reverse(result.begin(), result.end()); //后序遍历的结果翻转即是正常顺序
            return result;
        }
        return {};
    }

private:
    //构建邻接链表函数
    vector<list<int>> BuildList(int numCourses, vector<vector<int>> &prerequisites) {
        vector<list<int>> my_list(numCourses, list<int>());
        for (auto &prerequisite : prerequisites) {
            int from = prerequisite[1];
            int to = prerequisite[0];
            my_list[from].push_back(to);
        }
        return my_list;
    }

    //DFS
    void travel(int cur, vector<list<int>> &my_list) {
        if (on_path[cur]) //如果回到入口，说明有环存在
            has_circle = true;
        if (visited[cur])
            return;
        on_path[cur] = true;  //入口标记位进行标记(此变量需要回溯，因为有多个分岔点)
        visited[cur] = true;  //访问标记，此变量不需要进行回溯
        for (auto &ele : my_list[cur]) //DFS
            travel(ele, my_list);
        result.push_back(cur);    //加入结果集
        on_path[cur] = false;     //回溯
    }

private:
    vector<bool> visited; //记录访问变量
    vector<bool> on_path; //入口记录变量,用于判断有无环
    vector<int> result;   //结果集
    bool has_circle;      //判断有无环
};
```

--- 

### 名流问题
- **原题**
```
Suppose you are at a party with n people (labeled from 0 ton - 1) and among them, there may exist one celebrity. 
The definition of a celebrity is that all the othern - 1 people know him/her but he/she does not know any of them.
Now you want to find out who the celebrity is or verify that there is not one. 
The only thing you are allowed to do is to ask questions like: "Hi, A. Do you know B?" to get information of whether A knows B. 
You need to find out the celebrity (or verify there is not one) by asking as few questions as possible (in the asymptotic sense).
You are given a helper function bool knows(a, b) which tells you whether A knows B. 
Implement a functionint findCelebrity(n), your function should minimize the number of calls toknows.
Note: There will be exactly one celebrity if he/she is in the party. 
Return the celebrity's label if there is a celebrity in the party. If there is no celebrity, return-1.
```
- n个人的社交关系:
  1. 其他所有人都认识这个人
  2. 这个人不认识其他所有人

**这个节点没有一条指向其他节点的有向边，且其他所有节点都有一条指向这个节点的有向边。**

- **优化版本解题思路**:
  1. 我们可以不断从候选人中选两个出来，然后排除掉一个，直到最后只剩下一个候选人，这时候再使用一个 for 循环判断这个候选人是否是货真价实的「名人」 

```C++
int findCelebrity(int n) {
    int candidate = 0;
    for (int other = 1; other < n; ++other) {
        //排除非名人
        if (!knows(other, candidate) || knows(candidate, other))
            candidate = other;
    }

    //单一进行判断剩下来的看是否是名人
    for (int other = 1; other < n; ++other) {
        if (!knows(other, candidate) || knows(candidate, other))
            return -1;
    }

    return candidate;
}
```

### Dijkstra算法
- 你第一次经过某个节点时的路径权重，**不见得就是最小**的，所以对于同一个节点，我们可能会经过多次，而且每次的 distFromStart 可能都不一样
- 此算法使用 **优先级队列** 可以加快效率，这是一种 **贪心** 之思想.

---

- **743 网络延迟时间**
```C++
class Solution {
public:
    int networkDelayTime(vector<vector<int>>& times, int n, int k) {
        BuildGraph(times, n);                                       //构建邻接矩阵
        vector<int> shortest_path(Dijsktra(graph_vec, k - 1, n)); //获得最短路径表
        int result = 0;
        for (int path : shortest_path) {
            result = max(result, path);
            if (path == INT_MAX)                                    //如果是MAX说明有的结点无法到达
                return -1;
        }
        return result;
    }

protected:
    //构建邻接矩阵，因为是从1到n，需要把所有索引减1
    void BuildGraph(vector<vector<int>> &times, int n) {
        graph_vec = vector<vector<int>> (n, vector<int> (n, INT_MAX));
        for (auto &time : times) {
            int from = time[0] - 1;
            int to = time[1] - 1;
            int weight = time[2];
            graph_vec[from][to] = weight;
        }
    }

    vector<int> Dijsktra(vector<vector<int>> &graph_vec, int start, int n) {
        std::priority_queue<int, std::vector<int>, std::greater<>> priority_Queue; //构建优先级队列
        vector<int> shortest_path(n, INT_MAX); //构建最短路径集
        shortest_path[start] = 0;                   //源结点到自身为0
        priority_Queue.push(start);

        //开始进行BFS
        while (!priority_Queue.empty()) {
            int cur_node = priority_Queue.top();
            priority_Queue.pop();
            vector<int> &link = graph_vec[cur_node]; //获得该结点的邻接结点
            for (int i = 0; i < link.size(); ++i) {
                int distance = link[i];               //此结点的邻接距离
                if (distance < shortest_path[i] - shortest_path[cur_node]) { //更新最短路径
                    shortest_path[i] = distance + shortest_path[cur_node];
                    priority_Queue.push(i);
                }
            }
        }
        return shortest_path;
    }

private:
    vector<vector<int>> graph_vec;
};
```

---

- **1514 概率最大的路径**
狄杰斯特拉算法本质是通过**增加一条边权重肯定增大**进行计算，而此题**增加一条边权重一定减少**，可以用狄杰斯特拉算法.
```C++
class Solution {
public:
    double maxProbability(int n, vector<vector<int>>& edges, vector<double>& succProb, 
                          int start, int end) {
        // 构建简化版邻接矩阵,无向图转化为有向图
        vector<vector<pair<int, double>>> graph(n);
        for (int i = 0; i < edges.size(); ++i) {
            int from = edges[i][0], to = edges[i][1];
            double weight = succProb[i];
            graph[from].emplace_back(to, weight);
            graph[to].emplace_back(from, weight);
        }

        //概率集,源结点到源结点概率为1
        vector<double> max_path(n, 0);
        max_path[start] = 1;

        //优先级队列，优化算法
        priority_queue<pair<int, double>> q;
        q.emplace(start, 1);

        //BFS进行遍历,该算法本质是多加一条边,单调增加或减少.
        while (!q.empty()) {
            auto [cur_node, odds] = q.top();
            q.pop();

            if (odds < max_path[cur_node])
                continue;
            
            auto &link = graph[cur_node];
            for (int i = 0; i < link.size(); ++i) {
                auto next_node = link[i].first;
                auto next_odds = link[i].second;
                // 如果概率增加,更新概率集,并且加入队列进行遍历
                if (odds * next_odds > max_path[next_node]) {
                    max_path[next_node] = odds * next_odds;
                    q.emplace(next_node, max_path[next_node]);
                }
            }
        }
        return max_path[end];
    }
};
```